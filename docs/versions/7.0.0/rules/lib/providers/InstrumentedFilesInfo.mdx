<html devsite>
<head>
  <meta name="project_path" value="/_project.yaml">
  <meta name="book_path" value="/versions/7.0.0/_book.yaml">
</head>
<body>

<h1 class="page-title" id="modules.InstrumentedFilesInfo">InstrumentedFilesInfo</h1>

{% dynamic setvar source_file "src/main/java/com/google/devtools/build/lib/starlarkbuildapi/test/InstrumentedFilesInfoApi.java" %}
{% dynamic setvar version "7.0.0" %}
{% dynamic setvar original_path "/rules/lib/providers/InstrumentedFilesInfo" %}
{% include "_buttons.html" %}
<!-- {% raw %} -->

Contains information about source files and instrumentation metadata files for rule targets matched by <a href="https://bazel.build/versions/7.0.0/reference/command-line-reference#flag--instrumentation_filter"><code>--instrumentation_filter</code></a> for purposes of <a href="https://bazel.build/versions/7.0.0/extending/rules#code_coverage">code coverage data collection</a>. When coverage data collection is enabled, a manifest containing the combined paths in <a href="#instrumented_files"><code>instrumented_files</code></a> and <a href="#metadata_files"><code>metadata_files</code></a> are passed to the test action as inputs, with the manifest's path noted in the environment variable <code>COVERAGE_MANIFEST</code>. The metadata files, but not the source files, are also passed to the test action as inputs. When <code>InstrumentedFilesInfo</code> is returned by an <a href="https://bazel.build/versions/7.0.0/rules/aspects">aspect</a>'s implementation function, any <code>InstrumentedFilesInfo</code> from the base rule target is ignored.

<h2>Members</h2>
<ul>
    <li>
    <a href="#instrumented_files">instrumented_files</a>
  </li>
      <li>
    <a href="#metadata_files">metadata_files</a>
  </li>
      <li>
    <a href="#to_json">to_json</a>
  </li>
      <li>
    <a href="#to_proto">to_proto</a>
  </li>
  </ul>

      <h2 id="instrumented_files">instrumented_files</h2>
        <p><pre class="rule-signature"><a class="anchor" href="../builtins/depset.html">depset</a> InstrumentedFilesInfo.instrumented_files</pre></p>

    <a href="../builtins/depset.html"><code>depset</code></a> of <a href="../builtins/File.html"><code>File</code></a> objects representing instrumented source files for this target and its dependencies.


        <h2 id="metadata_files">metadata_files</h2>
        <p><pre class="rule-signature"><a class="anchor" href="../builtins/depset.html">depset</a> InstrumentedFilesInfo.metadata_files</pre></p>

    <a href="../builtins/depset.html"><code>depset</code></a> of <a href="../builtins/File.html"><code>File</code></a> objects representing coverage metadata files for this target and its dependencies. These files contain additional information required to generate LCOV-format coverage output after the code is executed, e.g. the <code>.gcno</code> files generated when <code>gcc</code> is run with <code>-ftest-coverage</code>.


        <h2 id="to_json">to_json</h2>
        <p><pre class="rule-signature"><a class="anchor" href="../core/string.html">string</a> InstrumentedFilesInfo.to_json()</pre></p>

    <b>Deprecated</b>. This API is deprecated and will be removed soon. Please do not depend on it. It is <i>disabled</i> with <code>---incompatible_struct_has_no_methods</code>. Use this flag to verify your code is compatible with its imminent removal. <br>Creates a JSON string from the struct parameter. This method only works if all struct elements (recursively) are strings, ints, booleans, other structs, a list of these types or a dictionary with string keys and values of these types. Quotes and new lines in strings are escaped. Examples:<br><pre class=language-python>struct(key=123).to_json()
# {"key":123}

struct(key=True).to_json()
# {"key":true}

struct(key=[1, 2, 3]).to_json()
# {"key":[1,2,3]}

struct(key='text').to_json()
# {"key":"text"}

struct(key=struct(inner_key='text')).to_json()
# {"key":{"inner_key":"text"}}

struct(key=[struct(inner_key=1), struct(inner_key=2)]).to_json()
# {"key":[{"inner_key":1},{"inner_key":2}]}

struct(key=struct(inner_key=struct(inner_inner_key='text'))).to_json()
# {"key":{"inner_key":{"inner_inner_key":"text"}}}
</pre>.<p>Deprecated: instead, use json.encode(x) or json.encode_indent(x), which work for values other than structs and do not pollute the struct field namespace.


        <h2 id="to_proto">to_proto</h2>
        <p><pre class="rule-signature"><a class="anchor" href="../core/string.html">string</a> InstrumentedFilesInfo.to_proto()</pre></p>

    <b>Deprecated</b>. This API is deprecated and will be removed soon. Please do not depend on it. It is <i>disabled</i> with <code>---incompatible_struct_has_no_methods</code>. Use this flag to verify your code is compatible with its imminent removal. <br>Creates a text message from the struct parameter. This method only works if all struct elements (recursively) are strings, ints, booleans, other structs or dicts or lists of these types. Quotes and new lines in strings are escaped. Struct keys are iterated in the sorted order. Examples:<br><pre class=language-python>struct(key=123).to_proto()
# key: 123

struct(key=True).to_proto()
# key: true

struct(key=[1, 2, 3]).to_proto()
# key: 1
# key: 2
# key: 3

struct(key='text').to_proto()
# key: "text"

struct(key=struct(inner_key='text')).to_proto()
# key {
#   inner_key: "text"
# }

struct(key=[struct(inner_key=1), struct(inner_key=2)]).to_proto()
# key {
#   inner_key: 1
# }
# key {
#   inner_key: 2
# }

struct(key=struct(inner_key=struct(inner_inner_key='text'))).to_proto()
# key {
#    inner_key {
#     inner_inner_key: "text"
#   }
# }

struct(foo={4: 3, 2: 1}).to_proto()
# foo: {
#   key: 4
#   value: 3
# }
# foo: {
#   key: 2
#   value: 1
# }
</pre><p>Deprecated: use proto.encode_text(x) instead.



</body>
</html>

<!-- {% endraw %} -->
